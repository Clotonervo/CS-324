*** YOU CAN TAKE IN ONE SHEET OF NOTES ***


Environment
  - setting environment for program execution
    > TEST="this-is-a-test"
    > export TEST
      * OR export ENV_NAME="this is a test"
    > unset TEST - will remove variable
    > echo $TEST - will print its definition

  - retrieving environment (e.g., from within C)
    > getenv("SLOWCAT_SLEEP_TIME") ---> getnenv("ENV_NAME")


File descriptors
  - stdin, stdout, stderr
  	> stdin = 0
  	> stdout = 1
  	> stderr = 2

  - redirection / duplication within a program
    > /bin/cat file.txt 2 >  &1
      * Redirect stderr(2) to same place as stdout(1)
    > 2>/dev/null will take out all stderr

  - pipe concepts
    > int p[2]; pipe(p);
    > p[1] = write end
    > p[0] = read end
    > you should close one end of the pipe before doing anything, close(p[1]) [closes the write end]

  - dup2() concepts
    > dup2(1,2)
      * Takes the stdout(1) and pushes it into stderr(2)
      * Takes the stdout(1) and now everything that goes to stdout goes to stderr(2)
      * dup2(1,2) = 1>&2

Shell usage
  - file descriptor redirection / duplication
  - shell pipelines
  	> Takes stdout of the first program and puts it into stdin of next program
  	  * ./program1 | ./program2

  - jobs / job control
    - background / foreground / suspend
    	> To run a job in the background, put a & on it
    	> To suspend a job, kill -STOP <pid>
    	> To resume it, kill -CONT <pid>
    	> The "ps" command will give you pids
    > Every Job has a process, but not every process is a job

  - basic usage of echo, cat, grep
    > Grep: ./program | grep [STRING]
      * Ex. ./program | grep bob  => gives you all lines that contains "bob" in them (-v is everything but)
    > Echo: Echos the result

    > Cat: prints out file, must be used for redirection, stdout of last program used as stdin to the next one

Processes
  - fork
      > if ((pid = fork()) == 0){
              printf("a");
            }
        printf("b");

        // Child will print both "a" and "b", but parent will only print "b"

    - concurrency, concurrent execution
      > Both child and parent will jump back and forth with execution

    - synchronization with wait() / waitpid()
      > wait(): Will make that process wait until its children are done, and then it will reap them
      > waitpid(): Will wait for a certain pid to finish before continuing
      	> (fg_job_pid = waitpid(-1, &status, WNOHANG | WUNTRACED))

  - exec
    > Replaces current process execution with the parameters given
    > Only returns if it errors

  - orphaned processes ("daemons")
    > Process thats always running in the background
    > Its important that it cleans up its children, because if it doesn't then it will take up a whole lot of resources
    > Zombie children wont be reaped unless explicitly 

  - zombies/reaping
  	> Finished child processes, needs to be reaped by parents to be taken out of the process table

  - process groups, setpgid(), how a shell handles groups with signals, etc.
  	> setpgid(0,0); Sets the group pid of a pid to itself, so that when a signal gets sent, it only affects every process in that group
  	> Goes first to each handler depending on the signal, and sends the signal to the child process and goes through the child handler.

  - retrieving status from exited child processes with macros: WIFEXITED/WIFSTOPPED/WIFSIGNALED/etc.
  	> (Child handler)
	  	sigset_t mask, prev;
	    sigfillset(&mask);
	    sigprocmask(SIG_BLOCK, &mask, &prev);
	    
	    int status;
	    while((fg_job_pid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0){
	       
	        if (WIFSIGNALED(status)) {
	            printf("Job [%d] (%d) terminated by signal %d\n", pid2jid(fg_job_pid), fg_job_pid, WTERMSIG(status));
	            deletejob(jobs, fg_job_pid);
	        }
	        else if (WIFSTOPPED(status)) {
	            printf("Job [%d] (%d) stopped by signal %d\n", pid2jid(fg_job_pid), fg_job_pid, WSTOPSIG(status));
	            getjobpid(jobs,fg_job_pid)->state = ST;
	        }
	        else if (WIFEXITED(status)){
	            deletejob(jobs, fg_job_pid);
	        }
	    }

Exceptions
  - asynchronous vs. synchronous
    > Asynchronous: Interrupts the execution of your program sequencially, Something you cause
    > Synchronous: Will jump you out of your code once its hit, Most often system calls
      * Reading from a file, exec, writing to a file, dup2()

 * - traps, faults, aborts
    > Traps: Are intentional, system call
    > Faults: Unintentional, but might be recoverable (but some are not), something you have caused
    > Aborts: Unintentional and unrecoverable. Called from outside of you


Signals
    - Signal blocking
      > You can't block a SIGKILL or a SIGSTOP signal
      > Block signals from interrupting a program or a child, helps with race errors and concurrency issues.

    - Sending vs. receiving a signal
      > int kill(pid_t pid, int sig); 
      > Sends a signal to a pid, put a - infront to also send to whole group

    - SIGCHLD, SIGINT, SIGTSTP, SIGCONT, SIGTERM, SIGKILL
      > SIGCHLD gets sent to parent after child has exited or stopped or terminated
      > SIGINT is sent, inturrupts the process. Also can be sent by ^C
      > SIGTSTP is sent, and stops the process. Also can be sent by ^Z
      	> SIGSTOP is the same but must be sent programatically from kill
      > SIGCONT continues a stopped process
      > SIGTERM terminates a process
      > SIGKILL does the same as SIGTERM, but can't be blocked is like a force quit.

    - Default actions, overriding with handlers or with SIG_DFL (default) or SIG_IGN (ignore).
      > SIG_DFL specifies the default action for the particular signal.
      > SIG_IGN specifies that the signal should be ignored.
      	> signal(SIGTERM, SIG_IGN);
      	> #include <signal.h>

    - Signal blocking with sigprocmask()
      > int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
	      > SIG_BLOCK is the set of blocked signals, union of of the current set and the set argument
	      > SIG_UNBLOCK makes the signals in the set removed from the current set of block signals
	      > SIG_SETMASK the set of blocked signals is set to the argument
	      > Blocking:
	      	sigemptyset(&mask);
	        sigaddset(&mask, SIGCHLD); (or sigfillset(&mask))
	        sigprocmask(SIG_BLOCK, &mask, &prev);

	      > Unblocking:
	        sigprocmask(SIG_SETMASK, &prev, NULL);


Virtual Memory
  - Virtual addressing and pages
  - Page table / Page table entries (PTE)
  - Identifying VPN and VPO given a VA
    > Page size = N, so where 2^n = N
    > 2^n, where n is the number of bits for the VPO, and the VPN is the rest

  - Identifying PPN and PPO given a VA and a PTE
  - Identifying a PA given a PPN and PPO
  - TLB - access using TLB index, TLB tag
    > TLB Hit when it is in the table AND valid
    > TLB Stuff comes from VPN first
      * TLBI is TLB Index and comes from the number of sets
      * TLBT is TLB Tag, and comes from the rest of the VPN

  - Find a byte of data given a virtual address





