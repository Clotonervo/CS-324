1. When comparing strings, you can't use == or != operators as they simply will compare the addresses of the characters rather than the actual characters themselves, you must use strcmp();

2. Strings in C are stored in read-only memory, and the only way to modify a string is to copy the string and modify its contents using a strcpy(). The reason this function does not work as intended is that the string "Hello World!" is seen as a string literal, but is not read as a char[] as str is. To reassign a value to str, we need to use strcpy().

3. The reason this one does not work is because the function was trying to return a local variable, and the memory for the copied string was not allocated on the stack. By using malloc(), we can allocate the memory needed for the string in memory, so that the pointer returned can still point to that string we just copied.

4. The reason this one doesn't work is when you pass in an array in C, it decays into a pointer to the first element. There is no way to determine the full size of the array. Because the size of a char* = 8 bytes, it registers the size of the array as 8. The only way to determine the array size is to pass it into the function. When you instead pass in the array size at the call of the function, it registers the correct size and copies the whole array. Without doing this memcpy() only copies the first 8 bytes instead of the first 10.

5. The reason case 5 didn't work was because in the memcpy() function, we needed to treat the start of the substring (str[begin]) as a pointer for memcpy() to start at, rather than just the char*. We needed to dereference the pointer so it was copying the memory at the address rather than the actual address.

6. strtok() alters the original string by placing a null terminal character at the delimiter. In order to keep the same functionalitiy we need to copy the string over to a temporary string, and use that string to call strtok() and convert it into its token/substring.