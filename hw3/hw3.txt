1. exec.c first sleeps for 30 seconds after printing out the pid. Then if there is a program to exec (as in if there is an argc > 1), then it will move on to the "running exec" print statement. If there is a program, then it will call execve() with the program and pass in the created newenviron char pointer. After that program is done running, it will call the last print statement.

2. The last print statment will only be printed if there is a program to run and if said program finishes running and returns back to the exec program.

3. Sams-Air-3:hw3 samhopkins$ ./exec /bin/cat
Program "./exec" has pid 47780. Sleeping.
Running exec of "/bin/cat"                            


4. Sams-Air-3:~ samhopkins$ ps -p 47780 -o user,pid,ppid,state,comm 
USER         PID  PPID STAT COMM
samhopkins 47780 37012 S+   ./exec
Sams-Air-3:~ samhopkins$ ps -p 47780 -o user,pid,ppid,state,comm 
USER         PID  PPID STAT COMM
samhopkins 47780 37012 S+   /bin/cat

5. Both outputs had the same pid and the same parent ID. While they both also had similar states, the only reall thing that seemed to change was the executed program. Its interesting because it seems that the function that was called inside of exec really did execute the /bin/cat program on the same process.

6. Sams-Air-3:hw3 samhopkins$ ./exec program-doesnt-exist
Program "./exec" has pid 48622. Sleeping.
Running exec of "program-doesnt-exist"
End of program "./exec".

Sams-Air-3:~ samhopkins$ ps -p 48622 -o user,pid,ppid,state,comm 
USER         PID  PPID STAT COMM
samhopkins 48622 37012 S+   ./exec
Sams-Air-3:~ samhopkins$ ps -p 48622 -o user,pid,ppid,state,comm 
USER   PID  PPID STAT COMM

It seemed that as soon as the program ran and finished that the process terminated itself. Kind of like discussed in class, a fork would need to be called in order to continue the process, because after the executed program returned, process (in this case 48622) then terminated itself.

7. From looking at fork.c, it seems to call a series of fork() functions with sleeps inside them. Then it has certain sections for the child and the parent to run through the program. For example, the child created before section A would hit the section A print statement, but then go through the section B conditional, while the parent will go through section C. Neither paths seem to even reach section D.

8. Section A: is ran by both, Section B: is only by the child, Section C: is only by adult, and neither make it to Section D.

9. 

h0pkins3@carolina:~/Desktop/CS-324/hw3$ ./fork                    
Starting program; process has pid 24002                           
Section A;  pid 24002                                             
Section A;  pid 24003                                             
Section C                                                         
Section B                                                         
Section B done sleeping                                           
Section C done sleeping                                           


│h0pkins3@carolina:~/Desktop/CS-324/hw3$ ps -p 24002,24003 --forest -o user,pid,ppid,state,comm //Before 30 sleep
│USER       PID  PPID S COMMAND
│h0pkins3 24002 23741 S fork
│h0pkins3 24003 24002 S  \_ fork
│h0pkins3@carolina:~/Desktop/CS-324/hw3$ ps -p 24002,24003 --forest -o user,pid,ppid,state,comm //After Section B done sleeping
│USER       PID  PPID S COMMAND
│h0pkins3 24002 23741 S fork
│h0pkins3 24003 24002 Z  \_ fork <defunct>
│h0pkins3@carolina:~/Desktop/CS-324/hw3$ 

10. What was interesting is how the fork created the child and how they both went down different code paths. I also thought it was interesting how when you tried to show the different processes after Section B was done sleeping, the child process was no longer sleeping but was put in Zombie mode because it had hit an exit(0). This was the major difference between the two outputs, and its a result of the child hitting the end of its branch in the program before the parent, so it finished the program before the parent

11. You would want to put a wait(0) right inbetween the two sleep(30) in Section C. It would then wait for the child process to terminate and then the parent would reap it.

12. h0pkins3@california:~/Desktop/CS-324/hw3$ ./fork                
Starting program; process has pid 21047                             
Section A;  pid 21047                                               
Section A;  pid 21048                                             
Section B                                                         
Section C                                                          
Section C done sleeping                                            
h0pkins3@california:~/Desktop/CS-324/hw3$ Section B done sleeping 

h0pkins3@california:~/Desktop/CS-324/hw3$ ps -p 21047,21048 --forest -o user,pid,ppid,state,comm
│USER       PID  PPID S COMMAND
│h0pkins3 21047 20865 S fork
│h0pkins3 21048 21047 S  \_ fork
│h0pkins3@california:~/Desktop/CS-324/hw3$ ps -p 21047,21048 --forest -o user,pid,ppid,state,comm
│USER       PID  PPID S COMMAND
│h0pkins3 21048     1 S fork

13. The parent process exited first, which then terminated the program. The child process, however, continued its program and outputted that Section B was done sleeping after I had already exited the program. The reason being the parent process is the one we are interested in during the program, when it returns we return too. The child process simply does it's own thing, and its PPID then gets set to 1 instead of the old parent id. 

14. h0pkins3@california:~/Desktop/CS-324/hw3$ cat fork-output.txt       
Section A                                                                                
Section C
Section A                                                            
Section B   

15. The parent process continues on, seemingly running through the program before the child process does. It seems to complete its program before the child process is able to start its own branch. This behavior is apparent due to Section A and C being executed before the child process is able to print that it is in Section A and B.

16. Sams-MacBook-Air-3:hw3 samhopkins$ ./fork
Starting program; process has pid 22463
Section A;  pid 22463
Section C
Section A;  pid 22464
Section B
Section B done sleeping
hello from Section B
Section C done sleeping












